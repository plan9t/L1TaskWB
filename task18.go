//Реализовать структуру-счетчик, которая будет инкрементироваться в конкурентной среде.
//По завершению программа должна выводить итоговое значение счетчика.

package main

import (
	"fmt"
	"sync"
)

type Counter struct {
	mu    sync.Mutex // Без мьютекса результат может быть непредсказуемым, так как может быть несинхронизированный доступ к значению счётчика из разных горутин
	value int        // Само значение счётчика
}

func (c *Counter) Increment() {
	c.mu.Lock()         // Лочим мьютекс перед изменением общего ресурса
	defer c.mu.Unlock() // Освобождаем мьютекс после завершения операции
	c.value++           // Инкрементируем значение счетчика
}

func (c *Counter) GetValue() int {
	c.mu.Lock()         // Лочим мьютекс перед изменением общего ресурса
	defer c.mu.Unlock() // Освобождаем мьютекс после завершения операции
	return c.value      // Возвращаем текущее значение счетчика
}

func main() {
	counter := Counter{} // Создаем экземпляр счетчика

	var wg sync.WaitGroup // WaitGroupдля ожидания завершения всех горутин

	for i := 0; i < 100; i++ {
		wg.Add(1) // Увеличиваем счетчик WaitGroup
		go func() {
			counter.Increment() // Инкрементируем счетчик в каждой горутине
			wg.Done()           // Уменьшаем счетчик WaitGroup после завершения горутины
		}()
	}

	wg.Wait() // Ожидаем завершения всех горутин

	fmt.Println("Итоговое значение счетчика:", counter.GetValue()) // Чек в выводе
}
