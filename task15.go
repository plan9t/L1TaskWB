//К каким негативным последствиям может привести данный фрагмент кода, и как это исправить?
// Приведите корректный пример реализации.
//
//
//var justString string // Объявление пустой строки, Она используется только в функции, можно объявить её там.
//func someFunc() {
//v := createHugeString(1 << 10) // Создание строки длиной 1024 символа. 000000000001 --> 100000000000
// ПРОБЛЕМА: Возможно выделение сильно большего объема памяти, чем потребуется.
//
//justString = v[:100] // После присваивания через срез переменная justString становится
// равной первым 100 символам переменной v.
// Длина v - 1024. В justString мы используем 100/1024 Симоволов,
// остальные 924 символа в justString мы просто не используем, а в памяти они останутся.
// ПРОБЛЕМА: Избыточное выделение памяти

//}
//
//func main() {
//someFunc()
//}

// Избавление от глобальной justString, можно обойтись и без неё. Плюсы:
// 1 Избавились от потенциальной проблемы, когда в других возможных функция значение justString может измениться,
// что может привести не неопределённым исходам
// 2 Код читаемее
// 3 Уменьшение объема используемой памяти
// 4 Глобальные переменные находятся на куче, а локальные на стеке. С последним работа быстрее. Оптимизация
// 5 От переменной v тоже избавились, код стал ещё читаемее
// 6 Возвращаем результат для предотвращения его потери.

package main

func someFunc() string {
	return createHugeString(1 << 10)[:100]
}

func main() {
	someFunc()
}

// Заглушка для IDE
func createHugeString(i int) string {
	return ""
}
