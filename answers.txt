Устные вопросы

1. Какой самый эффективный способ конкатенации строк?

Ответ: string.Builder. Если использовать внешние пакеты ("github.com/Quasilyte/concat"), то можно ещё быстрее.

Ещё эффективнее: Оптимизация функции concatstrings (ТОЛЬКО ДЛЯ ЧАСТНЫХ СЛУЧАЕВ).
Эта функция используется в concatstring1(2,3,4,5), вызываемой рантаймом го при "+"
Кодогенерация для конкатенации. https://habr.com/ru/articles/417479/



2. Что такое интерфейсы, как они применяются в Go?
Интерфейсный тип в Go — это своего рода определение.
Он определяет и описывает конкретные методы, которые должны быть у какого-то другого типа.

Хороший пример с Хабр:
package main

import (
    "fmt"
    "strconv"
    "log"
)

// Объявляем тип Book, который удовлетворяет интерфейсу fmt.Stringer.
type Book struct {
    Title  string
    Author string
}

func (b Book) String() string {
    return fmt.Sprintf("Book: %s - %s", b.Title, b.Author)
}

// Объявляем тип Count, который удовлетворяет интерфейсу fmt.Stringer.
type Count int

func (c Count) String() string {
    return strconv.Itoa(int(c))
}

// Объявляем функцию WriteLog(), которая берёт любой объект,
// удовлетворяющий интерфейсу fmt.Stringer в виде параметра.
func WriteLog(s fmt.Stringer) {
    log.Println(s.String())
}

func main() {
    // Инициализируем объект Book и передаём в WriteLog().
    book := Book{"Alice in Wonderland", "Lewis Carrol"}
    WriteLog(book)

    // Инициализируем объект Count и передаём в WriteLog().
    count := Count(3)
    WriteLog(count)
}


3. Чем отличаются RWMutex от Mutex?
Mutex обеспечивает эксклюзивный доступ к ресурсу.
Это означает, что в любой момент времени только одна горутина может держать Mutex,
и остальные будут заблокированы до тех пор, пока мьютекс не будет освобожден.

RWMutex также обеспечивает мьютекс, но с более гибкими правами доступа. Он разделяет доступ на чтение и запись.
Несколько горутин могут одновременно держать RWMutex для чтения (блокировка на чтение),
но только одна горутина может держать его для записи (блокировка на запись).
Это полезно в ситуациях, где большая часть доступа - только для чтения, и блокировка на запись может быть
установлена только в том случае, если горутина планирует изменять данные.


4. Чем отличаются буферизированные и не буферизированные каналы?
Go каналы представляют собой механизм для взаимодействия между горутинами.
Каналы могут быть буферизированными и не буферизированными, и это влияет на их поведение.

    Размер буфера:

            Не буферизированный канал: Он не имеет буфера или имеет буфер размером 1 (только для передачи).
    Это означает, что отправитель и получатель должны быть готовы к взаимодействию в один момент времени.
    Если нет получателя, отправитель блокируется, и наоборот. Это обеспечивает синхронизацию между горутинами.
            Буферизированный канал: Он имеет фиксированный размер буфера, и горутины могут отправлять данные в канал,
    даже если нет готового получателя. Отправитель не блокируется, пока буфер не заполнится.
    По сравнению с не буферизированными каналами, буферизированные каналы могут быть более эффективными в сценариях,
    где производительность важна.



    Блокировка:

            Не буферизированный канал: Отправка в не буферизированный канал блокирует отправителя до момента,
    когда данные не будут прочитаны получателем, и наоборот. Это создает явную синхронизацию между горутинами.
            Буферизированный канал: Отправка в буферизированный канал блокирует отправителя только в том случае,
    если буфер полностью заполнен. Получатель блокируется только в том случае, если буфер пуст.



    Гарантированность доставки:

            Не буферизированный канал: Гарантирует, что данные будут доставлены в том порядке, в котором они были отправлены
    (FIFO - "first in, first out").
            Буферизированный канал: Гарантирует, что данные будут доставлены в том порядке, в котором они были отправлены,
    но только до размера буфера. Если буфер полностью заполнен, отправка новых данных блокируется до освобождения места в буфере.

5. Какой размер у структуры struct{}{}?
size := unsafe.Sizeof(struct{}{})
 0 bytes
нет полей

6. Есть ли в Go перегрузка методов или операторов?

В Go нет поддержки перегрузки методов или операторов в том смысле, в каком она реализована в некоторых других
языках программирования, таких как C++ или Java.
В Go, методы и операторы могут быть определены только один раз для каждого имени.

Однако Go предоставляет интерфейсы, которые позволяют создавать код, который работает с различными типами данных,
если они реализуют одинаковый интерфейс. Это позволяет достичь похожего результата, не прибегая к перегрузке методов.


7. В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0]=1
m[1]=124
m[2]=281


В Go порядок итерации по элементам карты (map) является случайным и не гарантированно сохраняет порядок вставки элементов.
Это связано с тем, что реализация карты использует хэш-таблицу для эффективного поиска, и порядок элементов зависит от хэш-функции
и внутренней организации хэш-таблицы.
Порядок вывода элементов карты в вашем примере (map[int]int) не гарантирован и может меняться при различных запусках программы.
Если нужен порядок, можно использовать срезы


8. В чем разница make и new?
Метод make () выделяет место в памяти только для типов slice, map и chan и инициализирует объект.
Его первый параметр - это тип, а второй параметр - параметр переменной длины, который возвращает сам тип.

Для типа среза (среза) первый размер представляет длину среза, а второй размер представляет собой емкость среза. Если указан только один параметр размера, емкость среза равна его длине;
Для типа карты (словаря) существует только один размер, который указывает, сколько места выделено для карты. Если этот параметр опущен, автоматически выделяется небольшое пространство (этот параметр обычно не требуется, поскольку карта автоматически расширяется);
Для типа chan (pipe) существует только один размер, который представляет буфер канала, и отсутствие параметра означает отсутствие буфера.

Метод new () выделяет место в памяти. Его первым параметром является тип, а затем он возвращает указатель на область памяти этого типа.


9. Сколько существует способов задать переменную типа slice или map?
    СРЕЗЫ:
    1. С использованием литерала среза.
        numbers := []int{1, 2, 3, 4, 5}

    2. С использованием функции make:
        numbers := make([]int, 5)  - Создает слайс с длиной 5

    3. С использованием среза существующего массива или другого слайса:
        array := [5]int{1, 2, 3, 4, 5}
        slice := array[1:4] // Срез из массива или слайса

    МАПЫ:
    1. С использованием литерала карты:
        ages := map[string]int{
            "Alice": 25,
            "Bob":   30,
            "Charlie": 35,
        }

    2. С использованием функции make:
        ages := make(map[string]int)

    3. С использованием литерала карты и последующего добавления элементов:
        ages := make(map[string]int)
        ages["Alice"] = 25
        ages["Bob"] = 30
        ages["Charlie"] = 35

    4. С использованием функции new для создания указателя на карту (реже используется):
        ages := new(map[string]int)
                Функция new для карты создает указатель, но не инициализирует саму карту,
                и такой подход может привести к панике при попытке добавления элементов.


10. Что выведет данная программа и почему?

func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

ОТВЕТ:
            1
            1

Пояснение:

В функции main создается переменная a со значением 1 и указатель p, который указывает на эту переменную.
Затем выводится значение, на которое указывает p (т.е., 1).
Затем вызывается функция update с указателем p. Внутри функции update создается переменная b со значением 2,
и указатель p присваивается указывать на b. Однако это изменение не влияет на оригинальный указатель p в функции main,
так как указатели передаются по значению в Go. После завершения функции update, переменная b уничтожается, и указатель
p возвращается к указыванию на переменную a.
Затем в функции main снова выводится значение, на которое указывает p.
Так как никаких изменений в указателе p не произошло в функции update, выводится значение переменной a (т.е., 1).


11. Что выведет данная программа и почему?


func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}

ОТВЕТ:
        4
        2
        3
        1
        0
        fatal error: all goroutines are asleep - deadlock!

Создается переменная wg типа sync.WaitGroup.
Запускается цикл с i от 0 до 4 включительно.
В каждой итерации цикла вызывается wg.Add(1), увеличивая счетчик WaitGroup на 1.
Запускается анонимная горутина go func(wg sync.WaitGroup, i int) {...}.
Внутри горутины выводится значение i и вызывается wg.Done() для уменьшения счетчика WaitGroup на 1.
Внутри горутины передается копия WaitGroup (wg) и i. Это ключевой момент, который вызывает проблему.

Проблема в том, что sync.WaitGroup передается внутрь горутины по значению, а не по указателю.
По указателю было бы так: (wg *sync.WaitGroup, i int)
Каждая горутина работает с своей собственной копией WaitGroup, и изменения, которые они вносят, не влияют на
оригинальный WaitGroup в цикле main.
После завершения цикла главная горутина вызывает wg.Wait(), ожидая,
пока счетчик WaitGroup не станет равным нулю. Однако, так как каждая горутина уменьшает свою собственную копию счетчика,
счетчик в оригинальном WaitGroup останется ненулевым, и программа заблокируется



12. Что выведет данная программа и почему?


func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}

ОТВЕТ:
            0
Внутри блока if true {...} мы объявляем новую переменную n с помощью краткого объявления переменной :=
Эта переменная n существует только в пределах блока if, и она скрывает переменную n, объявленную вне блока

Когда мы инкрементируем n внутри блока if, мы фактически изменяем только локальную переменную n внутри блока.
Когда блок завершается, локальная переменная n уничтожается, и программа использует внешнюю переменную n (которая в main),
которая остается равной 0.






13. Что выведет данная программа и почему?


func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}

ОТВЕТ:
            [100 2 3 4 5]

В функции someAction, параметр v передается по значению (как срез),
поэтому изменения внутри функции отразятся на оригинальном срезе,
но переназначение среза (v = append(v, b)) не изменит оригинальный срез,
так как срез передается по значению.

v[0] = 100 изменяет оригинальный срез a, поскольку он передается по ссылке.
v = append(v, b) создает новый срез (копию), к которому присваивается значение v, и добавляет элемент b в конец этой копии.
Изменения внутри функции someAction влияют на оригинальный срез a,
но переназначение v на новый срез не отражает эти изменения в вызывающей функции main.


14. Что выведет данная программа и почему?


func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}

ОТВЕТ:
		[b b a][a a]

Создается срез slice с элементами "a", "a".
Вызывается анонимная функция с параметром slice.
Внутри анонимной функции происходит следующее:
    slice = append(slice, "a") создает новый срез, который не влияет на оригинальный срез slice в main.
    Этот новый срез содержит элементы "a", "a", "a".
    slice[0] = "b" и slice[1] = "b" изменяют элементы нового среза на "b".
    fmt.Print(slice) выводит [bb a].
После выполнения анонимной функции, fmt.Print(slice) в main выводит исходный срез [a a], так как изменения внутри
анонимной функции не затрагивают оригинальный срез slice в main.